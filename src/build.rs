//! Site builder.
//!
//! Each submodule implements functions that represent a build task.

mod contents;
mod data_cascade;
mod feed;
mod front_matter;
mod global_data;
mod ignore;
mod layouts;
mod markdown;
mod minify_css;
mod minify_html;
mod minify_js;
mod minify_json;
mod minify_xml;
mod read_file;
mod scss;
mod sitemap;
mod syntax_highlight;
mod taxonomies;
mod typescript;
mod url;
mod write_file;

use std::{
    collections::HashMap,
    path::{Path, PathBuf},
};

use serde::{Deserialize, Serialize};
use walkdir::{DirEntry, WalkDir};

pub(self) use crate::{config::Config, error::Error};

/// Build entry.
///
/// A build entry represents a virtual file, that is either created from a
/// physical input file, or generated by Vitrine during the build.
#[derive(Clone, Debug, Default)]
pub(self) struct Entry {
    /// URL from which the entry will be accessible.
    ///
    /// The URL determines the output file name (e.g. `/blog/` outputs
    /// `/blog/index.html`).
    url: String,

    /// Content format.
    ///
    /// The format is usually determined by the input file extension (e.g.
    /// `html`).
    format: String,

    /// Input file information.
    ///
    /// This field contains a [`walkdir::DirEntry`] when the build entry
    /// originates from a physical file. It is `None` when the build entry is
    /// generated by Vitrine.
    input_file: Option<DirEntry>,

    /// Content of the entry.
    ///
    /// This field contains the processed content. When the content is `None`,
    /// the entry should be associated to a physical input file, which
    /// should be directly copied to the destination.
    content: Option<String>,

    /// Metadata associated to the entry.
    ///
    /// Metadata contain user-defined fields, sometimes used by build tasks,
    /// e.g. when rendering layouts.
    data: Option<EntryData>,
}

impl Entry {
    /// Get the input file path, if any.
    fn input_path(&self) -> Option<&Path> {
        self.input_file.as_ref().map(|v| v.path())
    }

    /// Get the input file path as [`std::path::PathBuf`], if any.
    fn input_path_buf(&self) -> Option<PathBuf> {
        self.input_file.as_ref().map(|v| v.path().to_owned())
    }
}

/// Metadata associated to a build entry.
///
/// Metadata are provided by front matters or data files (e.g. JSON), and used
/// for rendering layouts.
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
struct EntryData {
    /// Override the entry URL.
    url: Option<String>,

    /// Entry title.
    #[serde(default)]
    title: Option<String>,

    /// Entry date.
    #[serde(default)]
    date: Option<String>,

    /// Associated contents.
    #[serde(default)]
    contents: HashMap<String, String>,

    /// Sitemap configuration.
    #[serde(default)]
    sitemap: Option<EntrySitemap>,

    /// Additional fields.
    #[serde(flatten)]
    extra: serde_json::Value,
}

/// Sitemap configuration for a build entry.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
enum EntrySitemap {
    /// If false, the build entry will not be shown in the sitemap.
    Bool(bool),
    /// Sitemap configuration for the build entry.
    Object {
        /// Date of last modification.
        #[serde(default)]
        lastmod: Option<String>,

        /// Change frequency.
        #[serde(default)]
        changefreq: Option<String>,

        /// Priority.
        #[serde(default)]
        priority: Option<f64>,
    },
}

/// Build the site from given configuration.
pub(super) fn build(config: &Config) -> Result<(), Error> {
    let start_time = std::time::Instant::now();

    let ignore_matcher = self::ignore::Matcher::new(config)?;

    let markdown_parser = self::markdown::Parser::new(config);

    let scss_compiler = self::scss::Compiler::new();

    let layout_engine = config
        .layouts_dir
        .is_some()
        .then(|| self::layouts::Engine::new(config))
        .transpose()?;

    let html_minifier = self::minify_html::Minifier::new();

    let global_data = global_data::read(config)?;

    let mut num_output_files: usize = 0;

    debug_assert!(config.input_dir.is_absolute());

    let entries = WalkDir::new(&config.input_dir)
        .into_iter()
        .filter_entry(|entry| {
            // Skip hidden and ignored files and directories
            entry.depth() == 0
                || (entry
                    .file_name()
                    .to_str()
                    .map(|file_name| !file_name.starts_with(".") && !file_name.starts_with("_"))
                    .unwrap_or(false)
                    && !config.input_ignore_paths.contains(&entry.path().to_owned())
                    && !ignore_matcher
                        .is_match(entry.path().strip_prefix(&config.input_dir).unwrap()))
        })
        .filter_map(|result| {
            // Ignore errors (e.g. permission denied)
            result.ok()
        })
        .filter(|entry| {
            // Keep only files, ignore directories
            entry.file_type().is_file()
        })
        .map(|entry| {
            // Create build `Entry` from walkdir's `DirEntry`
            let path = entry.path();
            let file_name = PathBuf::from(entry.file_name());

            // `strip_prefix()` should not fail since `config.input_dir` is the base path
            // and normalized
            let url = path
                .strip_prefix(&config.input_dir)
                .unwrap()
                .components()
                .fold(String::new(), |mut url, component| {
                    url.push('/');
                    url.push_str(component.as_os_str().to_str().unwrap());
                    url
                });

            // Determine the format from the file extension
            let format = file_name
                .extension()
                .and_then(|v| v.to_str())
                .unwrap_or_default()
                .to_owned();

            Ok(Entry {
                url,
                format,
                input_file: Some(entry),
                ..Default::default()
            })
        })
        .map(|entry| {
            // Read content
            entry.and_then(|entry| match entry.format.as_str() {
                "css" | "html" | "js" | "json" | "md" | "scss" | "toml" | "ts" | "xml" | "yaml" => {
                    self::read_file::read_entry(entry)
                },
                // Other files will be copied directly
                _ => Ok(entry),
            })
        })
        .map(|entry| {
            // Parse metadata
            entry.and_then(|entry| match entry.format.as_str() {
                "html" | "md" => self::front_matter::parse_entry(entry),
                "json" | "toml" | "yaml" => self::data_cascade::parse_entry(entry),
                _ => Ok(entry),
            })
        });

    // Apply data cascade
    let entries = self::data_cascade::cascade_entries(entries)?;

    let entries = entries
        .map(|entry| {
            // Normalize URLs
            entry.and_then(|entry| match entry.format.as_str() {
                "html" | "md" => self::url::normalize_entry(entry),
                _ => Ok(entry),
            })
        })
        .map(|entry| {
            // Parse/compile Markdown/SCSS/TypeScript
            entry.and_then(|entry| match entry.format.as_str() {
                "md" => markdown_parser.parse_entry(entry),
                "scss" => scss_compiler.compile_entry(entry),
                "ts" | "tsx" => self::typescript::compile_entry(entry),
                _ => Ok(entry),
            })
        });

    // Bundle entries
    let entries = self::contents::bundle_entries(entries)?;

    // Group entries using taxonomies
    let (entries, global_data) = self::taxonomies::group_entries(entries, config, global_data)?;

    let entries = entries
        .map(|entry| {
            // Render layouts
            if let Some(layout_engine) = layout_engine.as_ref() {
                entry.and_then(|entry| match entry.format.as_str() {
                    "html" => layout_engine.render_entry(entry, &global_data),
                    _ => Ok(entry),
                })
            } else {
                entry
            }
        })
        .chain(self::syntax_highlight::create_stylesheet_entries(config));

    // Rewrite URLs
    let entries = self::url::rewrite_url_entries(entries, config)?;

    // Generate feeds
    let entries = self::feed::create_feeds_entries(entries, config)?;

    // Generate a sitemap
    self::sitemap::create_sitemap_entries(entries, config)?
        .map(|entry| {
            if !config.minify {
                return entry;
            }
            // Minify CSS/HTML/JS
            entry.and_then(|entry| match entry.format.as_str() {
                "css" => self::minify_css::minify_entry(entry),
                "html" => html_minifier.minify_entry(entry),
                "js" => self::minify_js::minify_entry(entry),
                "json" => self::minify_json::minify_entry(entry),
                "xml" => self::minify_xml::minify_entry(entry),
                _ => Ok(entry),
            })
        })
        .try_for_each(|entry| {
            // Write output files
            entry.and_then(|entry| {
                tracing::debug!("{:#?}", entry);
                if config.output_dir.is_some() {
                    self::write_file::write_entry(entry, config)?;
                    num_output_files += 1;
                }
                Ok(())
            })
        })?;

    let duration = start_time.elapsed().as_secs_f64();

    tracing::info!(
        "Wrote {} files in {:.2} seconds",
        num_output_files,
        duration
    );

    Ok(())
}
